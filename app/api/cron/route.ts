
import { NextResponse } from 'next/server';
import { Resend } from 'resend';

// Vercel Cron ÈúÄË¶Å maxDuration ËÆæÁΩÆËæÉÈïøÔºåÈò≤Ê≠¢ÁîüÊàêËøáÁ®ã‰∏≠Ë∂ÖÊó∂ (ËÆæÁΩÆ‰∏∫ 60Áßí)
export const maxDuration = 60;
// Âº∫Âà∂Âä®ÊÄÅÊâßË°åÔºå‰∏çÁºìÂ≠ò
export const dynamic = 'force-dynamic';

// ÁÆÄÂçïÁöÑ ID ÁîüÊàêÂô®
const generateId = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);

// --- Â§çÁî®ÈÇÆ‰ª∂Ê†∑ÂºèÁîüÊàêÈÄªËæë (‰øùÊåÅ‰∏ÄËá¥ÊÄß) ---
const EMAIL_STYLES = {
  container: "font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; max-width: 600px; margin: 0 auto; background-color: #ffffff; border: 3px solid #000000; color: #000000;",
  header: "background-color: #000000; color: #ffffff; padding: 24px 16px; border-bottom: 3px solid #000000;",
  headerTitle: "font-family: 'Impact', 'Arial Black', sans-serif; text-transform: uppercase; font-size: 32px; letter-spacing: -1px; line-height: 1; margin: 0;",
  headerMeta: "font-family: 'Courier New', Courier, monospace; font-size: 12px; margin-top: 8px; letter-spacing: 1px; opacity: 0.8;",
  sectionTitle: "background-color: #000000; color: #ffffff; font-family: 'Impact', 'Arial Black', sans-serif; font-size: 18px; text-transform: uppercase; padding: 4px 12px; display: inline-block; margin: 24px 0 0 -3px; transform: skewX(-10deg);",
  card: "border-bottom: 2px solid #000000; padding: 16px; display: block; background-color: #ffffff;",
  cardTitle: "font-family: 'Helvetica Neue', Arial, sans-serif; font-weight: 900; font-size: 18px; line-height: 1.1; color: #000000; margin: 0; flex: 1;",
  scoreBadge: "background-color: #000000; color: #ffffff; font-family: 'Courier New', monospace; font-weight: bold; font-size: 14px; padding: 2px 6px; border-radius: 0; min-width: 32px; text-align: center;",
  tagsRow: "margin-bottom: 8px; font-size: 10px; text-transform: uppercase; font-weight: bold; font-family: monospace;",
  tag: "display: inline-block; background-color: #f0f0f0; border: 1px solid #000; padding: 1px 4px; margin-right: 4px; color: #000;",
  summaryCn: "font-family: Georgia, 'Times New Roman', serif; font-size: 15px; line-height: 1.4; color: #000000; margin-bottom: 6px; font-weight: 500;",
  footer: "border-top: 3px solid #000000; background-color: #f4f4f4; padding: 20px; text-align: center; font-family: 'Courier New', monospace; font-size: 11px; color: #000000; font-weight: bold; text-transform: uppercase;"
};

const generateEmailHtml = (data: any) => {
  const renderItems = (items: any[]) => items.map(item => `
    <div style="${EMAIL_STYLES.card}">
      <div style="margin-bottom: 8px;">
         <div style="float: right; ${EMAIL_STYLES.scoreBadge}">${item.ai_score || '-'}</div>
         <div style="${EMAIL_STYLES.cardTitle}">${item.title}</div>
         <div style="clear: both;"></div>
      </div>
      
      <div style="${EMAIL_STYLES.tagsRow}">
        ${(item.tags || []).map((tag: string) => `<span style="${EMAIL_STYLES.tag}">${tag}</span>`).join('')}
        <span style="opacity:0.5; margin-left: 5px;">${item.source_name}</span>
      </div>

      <div style="${EMAIL_STYLES.summaryCn}">
        <div style="margin-bottom: 6px;">üá®üá≥ ${item.summary_cn}</div>
        <div style="color: #555; font-size: 0.9em;">üá∫üá∏ ${item.summary_en}</div>
      </div>
      <div style="margin-top: 8px;">
        <a href="${item.source_url}" style="color: #000; text-decoration: underline; font-size: 11px; font-family: monospace;" target="_blank">READ FULL ARTICLE &rarr;</a>
      </div>
    </div>
  `).join('');

  return `
    <!DOCTYPE html>
    <html lang="zh-CN">
    <head><meta charset="utf-8"><title>Hajimi Daily</title></head>
    <body style="margin: 0; padding: 0; background-color: #f4f4f4;">
      <div style="${EMAIL_STYLES.container}">
        <div style="${EMAIL_STYLES.header}">
          <h1 style="${EMAIL_STYLES.headerTitle}">Hajimi Daily</h1>
          <div style="${EMAIL_STYLES.headerMeta}">
             ISSUE: ${new Date().toLocaleDateString('en-GB').toUpperCase()} <span style="float:right">DIGITAL EDITION</span>
          </div>
        </div>
        <div style="padding: 0 16px;">
            <div style="${EMAIL_STYLES.sectionTitle}">CURRENT EVENTS // 10 ITEMS</div>
        </div>
        ${data.social && data.social.length > 0 ? renderItems(data.social) : '<p>ÊöÇÊó†ÂÜÖÂÆπ</p>'}
        <div style="padding: 0 16px;">
            <div style="${EMAIL_STYLES.sectionTitle}">HEALTH & HYGIENE // 10 ITEMS</div>
        </div>
        ${data.health && data.health.length > 0 ? renderItems(data.health) : '<p>ÊöÇÊó†ÂÜÖÂÆπ</p>'}
        <div style="${EMAIL_STYLES.footer}"><p>GENERATED BY ÂìàÂü∫Á±≥ AUTOMATION</p></div>
      </div>
    </body></html>
  `;
};

const generateEmailText = (data: any) => {
  let text = `HAJIMI DAILY - DIGITAL EDITION\nISSUE: ${new Date().toLocaleDateString('zh-CN')}\n\n`;
  const processSection = (title: string, items: any[]) => {
    text += `=== ${title} ===\n\n`;
    items.forEach((item, index) => {
      text += `${index + 1}. ${item.title} [Score: ${item.ai_score}]\nÊëòË¶Å(CN): ${item.summary_cn}\nSummary(EN): ${item.summary_en}\nÈìæÊé•: ${item.source_url}\n\n`;
    });
  };
  processSection("CURRENT EVENTS", data.social || []);
  processSection("HEALTH & HYGIENE", data.health || []);
  text += "\n----------------\nGENERATED BY ÂìàÂü∫Á±≥ AUTOMATION\n";
  return text;
};

// --- ‰∏ªÂ§ÑÁêÜÈÄªËæë ---

export async function GET(request: Request) {
  const startTime = new Date();
  console.log(`>>> [Cron] ‰ªªÂä°Ëß¶Âèë„ÄÇÊúçÂä°Âô®Êó∂Èó¥(UTC): ${startTime.toISOString()}`);

  const authHeader = request.headers.get('authorization');
  if (process.env.CRON_SECRET && authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    console.warn("Unauthorized Cron Attempt");
    return new NextResponse('Unauthorized', { status: 401 });
  }

  try {
    const apiKey = process.env.GEMINI_API_KEY;
    const baseUrl = process.env.GEMINI_BASE_URL || 'https://api.openai-proxy.com/v1'; 
    const model = process.env.GEMINI_MODEL || 'gemini-2.5-flash';
    const recipientsStr = process.env.RECIPIENTS;
    const resendApiKey = process.env.RESEND_API_KEY;

    if (!apiKey || !recipientsStr || !resendApiKey) {
      throw new Error("Missing Environment Variables: GEMINI_API_KEY, RECIPIENTS, or RESEND_API_KEY");
    }

    const recipients = recipientsStr.split(',').map(r => r.trim()).filter(Boolean);

    // ÂáÜÂ§áÊèêÁ§∫ËØç
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(today.getDate() - 1);
    const targetDateStr = yesterday.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    const queryDateStr = yesterday.toISOString().split('T')[0];

    const prompt = `
      You are an automated Daily Information Digest agent.
      Today is ${today.toISOString().split('T')[0]}.
      **TARGET DATE: ${targetDateStr} (${queryDateStr}).**
      
      ### CRITICAL INSTRUCTIONS
      1. **VOLUME**: You must find EXACTLY 20 ITEMS in total.
      2. **DIVERSITY**: Consult multiple sources. Do not rely on a single domain.
      3. **LINKS**: Ensure all source_urls are valid and accessible.
      4. **BILINGUAL**: The summary MUST include both English and Chinese versions in the JSON.
      5. **SCORING**: Rate items (0-100) based on Novelty, Fun, Virality, and Heat.
      
      Tasks:
      1. Find 10 Current Events items (Economy, Politics, Culture, Global).
      2. Find 10 Health & Hygiene items (Public health, wellness, biology).
      
      Output strict JSON: 
      { 
        "social": [{ "title": "...", "ai_score": 90, "tags": ["Viral"], ... }], 
        "health": [...] 
      }
      Fields: title, summary_en, summary_cn, source_url, source_name, ai_score, tags.
    `;

    // Ë∞ÉÁî® Gemini API
    const cleanBaseUrl = baseUrl.replace(/\/+$/, '').endsWith('/v1') ? baseUrl : `${baseUrl}/v1`;
    const targetUrl = `${cleanBaseUrl}/chat/completions`;

    console.log(`[Cron] Fetching content from ${targetUrl} with model ${model}...`);

    const payload: any = {
        model: model,
        messages: [{ role: "user", content: prompt }],
        response_format: { type: "json_object" }
    };

    if (!model.toLowerCase().includes('deepseek')) {
        payload.tools = [{ googleSearch: {} }];
    }

    // --- CRON API CALL WITH RETRY LOGIC ---
    let aiJson;
    try {
        const fetchWithPayload = async (p: any) => {
             const res = await fetch(targetUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify(p)
             });
             const text = await res.text();
             if (!res.ok) throw new Error(text); // Keep raw error text
             return JSON.parse(text);
        };

        try {
            aiJson = await fetchWithPayload(payload);
        } catch (firstErr: any) {
            const errorMsg = firstErr.message || '';
            console.warn(`[Cron] First attempt failed: ${errorMsg}`);
            
            // Retry for generic proxy errors
            if (errorMsg.includes("tool") || errorMsg.includes("bad_response_status_code") || errorMsg.includes("openai_error")) {
                 console.log("[Cron] Retrying without tools/json_format...");
                 if (payload.tools) delete payload.tools;
                 if (payload.response_format) delete payload.response_format;
                 aiJson = await fetchWithPayload(payload);
            } else {
                throw firstErr;
            }
        }
    } catch (finalErr: any) {
        throw new Error(`AI Request Failed: ${finalErr.message}`);
    }

    // Check for API-level errors inside 200 response
    if (aiJson.error) {
        throw new Error(`AI API Error (in body): ${aiJson.error.message || JSON.stringify(aiJson.error)}`);
    }

    const content = aiJson.choices?.[0]?.message?.content;
    if (!content) throw new Error("AI response content is empty or missing choices");

    // Ëß£Êûê JSON
    let digestData;
    let text = content.replace(/```json/g, "").replace(/```/g, "").trim();
    try {
        digestData = JSON.parse(text);
    } catch (e) {
        console.warn("[Cron] JSON parse failed, trying regex extraction...");
        const match = text.match(/\{[\s\S]*\}/);
        if (match) {
             try {
                 digestData = JSON.parse(match[0]);
             } catch (e2) {
                 throw new Error("Failed to parse extracted JSON");
             }
        }
        else throw new Error("Failed to parse AI JSON");
    }

    if (!digestData.social) digestData.social = [];
    if (!digestData.health) digestData.health = [];

    console.log(`[Cron] Content generated. Social: ${digestData.social.length}, Health: ${digestData.health.length}`);

    // ÂèëÈÄÅÈÇÆ‰ª∂ (‰∏≤Ë°åÊ®°Âºè + Âª∂Ëøü)
    const resend = new Resend(resendApiKey);
    const htmlContent = generateEmailHtml(digestData);
    const textContent = generateEmailText(digestData);
    const subjectLine = `Hajimi Daily #${new Date().toISOString().split('T')[0]}`;

    console.log(`[Cron] Sending emails to ${recipients.length} recipients (Sequential mode)...`);

    const results = [];
    for (const email of recipients) {
        console.log(`[Cron] Attempting to send to ${email}...`);
        try {
            const result = await resend.emails.send({
                from: 'Daily Pulse <digest@misaki1.de5.net>',
                to: [email],
                subject: subjectLine,
                html: htmlContent,
                text: textContent,
                headers: { 'X-Entity-Ref-ID': generateId() } // ‰ΩøÁî®Ëá™ÂÆö‰πâ ID ÁîüÊàêÂô®
            });
            console.log(`[Cron] Success: ${email} -> ID: ${result.data?.id}`);
            results.push({ email, ...result });
        } catch (err: any) {
            console.error(`[Cron] Failed to send to ${email}:`, err);
            results.push({ email, error: err.message });
        }
        
        // ÈÄüÁéáÈôêÂà∂‰øùÊä§: 1000ms Âª∂Ëøü
        await new Promise(r => setTimeout(r, 1000));
    }

    const failures = results.filter((r: any) => r.error);
    if (failures.length > 0) {
        console.error("[Cron] Some emails failed:", failures);
    }

    const endTime = new Date();
    const duration = (endTime.getTime() - startTime.getTime()) / 1000;

    return NextResponse.json({ 
        success: true, 
        message: `Cron job executed in ${duration}s.`,
        dataSummary: { social: digestData.social.length, health: digestData.health.length },
        failures: failures.length
    });

  } catch (error: any) {
    console.error("[Cron] Job Failed:", error);
    return NextResponse.json({ success: false, error: error.message }, { status: 500 });
  }
}
